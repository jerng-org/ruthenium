
<!DOCTYPE html>
<html>
    <head>
        
        <link   rel="stylesheet" 
                type="text/css" 
                href="https://ruthenium-v1.dev.sudo.coffee/?route=file&file=milligram.min.css">
        
        <link   href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" 
                rel="stylesheet">

        <link   href="https://fonts.googleapis.com/icon?family=Material+Icons"
                rel="stylesheet">
        
        <style>
            
        /* Application Milligram-Overrides */
        
            .material-icons {
                vertical-align: middle;
            }
            
            .button code {
                background-color: inherit;
            }
            
            thead sub,
            thead th:first-child
            {
                font-weight:300;
            }
            
            thead tr:last-child th[scope=col]:first-child {
                border-bottom:none;
            }

            th[scope=row] {
                border-bottom: 0.1rem solid #ddd;
            }
            
            th[scope=col]:not(:first-child) {
                border-left: 0.1rem solid #ddd;
            }

            tbody > tr:nth-child(odd) > td ,
            tbody > tr:nth-child(odd) > th {
                    background-image: linear-gradient(#f8f8f8, #fff, #fff, #fff, #f8f8f8);               
            }
            
            legend {
                padding: 0 1rem;
                background-color: #ccc;
                border-radius: 0.5em;
                font-family: mono
            }

        /* Application Original Content  */
            
            .ru-card { 
                border-radius: 0.5em;
                padding: 1em;
                border: 1px solid #ccc;
            }
            
            .ru-hover-opaque {
                opacity:0;
            }
            
            .ru-hover-opaque:hover {
                opacity:1;
            }
            
        </style>
        
        <script     nomodule 
                    src="https://ruthenium-v1.dev.sudo.coffee/?route=file&file=ruthenium-web-client.mjs"></script>
                    
        <script     type="module" 
                    src="https://ruthenium-v1.dev.sudo.coffee/?route=file&file=ruthenium-web-client.mjs"></script>
                    
        <script>
       
            /* Application Original Content (move to io/blobs/ later) */
         
            const toggler = ( scopingElement, classString, focusSelector ) => {
                
                Array.prototype.forEach.call ( 
                    scopingElement.querySelectorAll( classString ), 
                    e => {
                    
                        const wasVisible = ['','initial'].includes(e.style.display)
                        e.style.display = wasVisible ? 'none' : ''
                        
                        if (    (! wasVisible) && focusSelector ) 
                        { 
                            const focusTarget = scopingElement.querySelector ( focusSelector )
                            if ( Object.is ( focusTarget, e ) )
                            {
                            
                                console.warn('Not yet understanding why the events are triggered on focusTarget: focus->blur->focus ')
                                    
                                focusTarget.focus()
                                if ( focusTarget.select ) focusTarget.select()
                            }
                        }
                    } 
                )
            
            }
            
            
        </script>
 
    
    </head>
    <body>
        <a href="https://enter.dev.sudo.coffee/login?client_id=1ma6sqkfilca4ipvv90ko5qk3g&response_type=code&scope=openid&redirect_uri=https%3A%2F%2Fruthenium-v1.dev.sudo.coffee%2F%3Froute%3Dvirtual%26type%3Ddesk-schemas%26reader%3Dhuman">Log In</a>
        
        <div class="container">
            <h1>Welcome to Prototyping</h1>
            
            <a class="button" href="https://ruthenium-v1.dev.sudo.coffee/?route=initial&reader=human"><i class="material-icons">home</i></a>

            <hr>
            <p>
            </p>
            
<blockquote>
    WIP: 
</blockquote>
                            <label   for="desk-cells-as-csv"
                                    > 
                                    
Desk cells 
    <sub>
        CSV 
        <sup>
            as defined 
            <a href="https://tools.ietf.org/html/rfc4180#section-2">here</a>,
<blockquote>
with stricter requirements:
<br>(1) the first row WILL be treated as HEADERS,
<br>(2) unclosed quoted fields will result in a field abortion,
<br>(3) any failures will abort the overall parse
<br>( but good headers and records parsed so far, will be shown )
</blockquote>
        </sup>
    </sub>
    <script>

        console.warn('<< wrong place to put a script tag (WIP) >>')
        
        parseCsv = _text => {
            
            const _store = {

                parseAborted: false,
                fieldQuoteType: 0, // (where 0 => unknown, 1 => unquoted, 2 => quoted )
                headerFields: null,

                currentField: '',
                currentRecordFields: [],
                parsedRecords: []
            }
            const setFieldQuoteType = _type => {
                _store.fieldQuoteType = _type
            }
            
            const setHeaders = _ => {
                _store.headerFields = _store.currentRecordFields
            }
            
            const appendField = _char => {
                console.log('parseCsv(): appendField()')
                _store.currentField = _store.currentField + _char
            }
            
            const birthField = _ => {
                _store.currentRecordFields.push ( _store.currentField )
                _store.currentField = ''  // !!! RESET !!!
                _store.fieldQuoteType = 0  // !!! RESET !!!
            }
            
            const birthRecord = _ => {
                _store.parsedRecords.push ( _store.currentRecordFields )
                _store.currentRecordFields = [] // !!! RESET !!!
            }
            
            const abortField = _ => {
                _store.currentField = '' // !!! RESET !!!
            }
            
            const abortRecord = _ => {
                _store.currentRecordFields = [] // !!! RESET !!!
            }
            
            const abortParse = _msg => {
                abortField()
                abortRecord()
                _store.parseAborted = true
                _store.summary = 'parse aborted: ' + _msg
            }
            
            const recordLengthPass = _ => {
                const pass = _store.currentRecordFields.length == _store.headerFields.length
                if ( ! pass ) {
                    abortParse ('a record field-count was different from the header field-count') 
                }
                return pass 
            }
            
            const handleRecordEndOfTerm = _ => {
                if ( ! _store.headerFields) 
                {
                    setHeaders()
                    abortRecord()
                    //birthRecord()
                }
                else
                
                if ( recordLengthPass() )
                {
                    birthRecord()
                }
                
            }
            
            console.log('parseCsv(): before loop')
            
            if ( _text[ _text.length -1 ] == '\n' ) {
                _text = _text.substring(0, _text.length - 1);
            }
            for ( let index = 0; index <= _text.length; index++) {
                
                console.log('parseCsv(): char: ' + _text[index])
                
                if ( _store.parseAborted )
                { 
                    console.log('parseCsv(): parsedAborted==truthy')
                    break 
                }
                else 
                
                if ( undefined == _text[index] ) 
                {
                    if ( _store.fieldQuoteType == 2) {
                        abortParse('unclosed quoted field encountered at end of text')
                        break
                    }
                    // end of text
                    birthField()
                    handleRecordEndOfTerm()
                }
                else 
                {
                    console.log('parseCsv(): fieldQuoteType: ' + _store.fieldQuoteType)
                    switch (_store.fieldQuoteType)
                    {
                        case (0): // !!! NOT IN A FIELD !!!

                            switch (_text[index]) {

                                case ('"'):

                                    setFieldQuoteType(2)
                                    break

                                case (','):

                                    // EO-field
                                    birthField()
                                    break

                                case ('\n'):

                                    // EO-field, EO-record
                                    birthField()
                                    handleRecordEndOfTerm()
                                    break

                                default:
                                    setFieldQuoteType(1)
                                    appendField(_text[index])
                            }
                            break

                        case (1): // !!! IN AN UNQUOTED FIELD !!!

                            switch (_text[index]) {

                                case ('"'):

                                    abortParse('double-quote encountered in unquoted field')
                                    break

                                case (','):

                                    // EO-field
                                    birthField()
                                    break

                                case ('\n'):

                                    // EO-field, EO-record
                                    birthField()
                                    handleRecordEndOfTerm()
                                    break

                                default:
                                    appendField(_text[index])
                            }
                            break
                            
                        case (2): //  !!! IN A QUOTED FIELD !!!

                            switch (_text[index]) { // " ... 'it' ... below:"

                                case ('"'):

                                    switch (_text[index + 1]) {
                                    
                                        case ('"'):
                                            
                                            // 'it''s an ESCAPED double-quote
                                            appendField(_text[index])
                                            index++ // << skip forward >>
                                            break
                                        
                                       case (','):
                                       
                                            // 'it''s the CLOSING double-quote 
                                            // EO-field
                                            birthField()
                                            index++ // << skip forward >>
                                            break
                                        
                                        case ('\n'):
                                       
                                            // 'it''s the CLOSING double-quote 
                                            // EO-field, EO-record
                                            birthField()
                                            handleRecordEndOfTerm()
                                            index++ // << skip forward >>
                                            break
                                       
                                        case ( undefined ): 
                                        
                                            // 'it''s the CLOSING double-quote 
                                            // EO-field, EO-record, EO-text
                                            birthField()
                                            handleRecordEndOfTerm()
                                            index++ // << skip forward >>
                                            break
                                        
                                        default:
                                            // it's the CLOSING double-quote 
                                            abortParse('a double-quoted field was followed by an illegal character: ' + _text[index+1] )
                                    }
                                    break

                                default:
                                    appendField(_text[index])
                            }
                            break

                    }
                }
                    
                console.log('parseCsv(): _store: ' + JSON.stringify(_store,null,4))
                
            } // for
            
            if (!_store.parseAborted) {
                _store.summary = 'parse succeeded'
            }
            
            console.log('parseCsv(): summary: ' + _store.summary)
            
            return _store
        }
        
    </script>

                                    </label>
                    <textarea   type="text"
                                
                                id="desk-cells-as-csv"
                                name="desk-cells-as-csv""
                                
                                placeholder="--enter a PROPER comma-separated value--"
                                required
                                
                                onkeyup="
console.log('--start onkeyup--')
const textarea = document.getElementById('desk-cells-as-csv');
const textareaValue = textarea.value;
const outputElement = document.getElementById('desk-cells-as-csv-validity');
const parseResults = parseCsv(textareaValue);
outputElement.innerText = 'Summary : ' + parseResults.summary + '\n' +
    'Headers : ' + JSON.stringify(parseResults.headerFields,null,4) + '\n' +
    'Records : ' + JSON.stringify(parseResults.parsedRecords,null,4);
console.log('--end onkeyup--')
"
                            ></textarea><br>CSV Validation :
         <br><pre id="desk-cells-as-csv-validity"> nothing yet to show </pre><br>
         <pre>

TEST CSV INPUT DATA:

    ------ START BELOW ------      
"h1",h2,h3,h4
a,b,c,d
e,f,g,""
"""","


""

",,
h,i,j,k
"x,,,x","y,

y",,""""
    ------ STOP ABOVE ------      

         
RULES - based on RFC 4180 Section 2:

    0.  (Stricter than the RFC)
    
        If any RECORD is aborted, the entire parse is aborted.        
    
        (But good headers and records parsed so far, will be shown.)
    
    1.  From RFC's-2.3.
    
        Header presence is indicated by meta-data, so parser should ignore 
        this, HOWEVER, 
        
        (Stricter than the RFC)
        
            in our implementation we break from the RFC, and ASSUME THE 
            PRESENCE OF A HEADER.
        
            Therefore, for any data entered A HEADER IS MANDATORY.

    2.  From RFC's-2.2.
    
        Remove ONE (1) trailing CRLF, if present.
        
    3.  From RFC's-2.3.
    
        We COUNT the number of HEADER fields.
        
        If any RECORD has a different number of fields, the parser exits and 
        cleans up. 
        
        This further enforces the "same number of fields per record"
        requirement from the RFC's-4.

    4a.  Unquoted fields:
    
            From RFC's-2.4.
    
                Spaces are part of the field.
                
            Any of the following characters result in abortion of the
            record:
            
                - double-quote                  (from RFC's-4, 6)
                - comma                         (from RFC's-6)
                - line-breaks (CRLF) => (\n)   (from RFC's-6)
    
    4b. Quoted fields:
    
            From RFC's-2.7.
            
                If a double-(double-quote) is found, this is read as part of the
                field, and parsing of the field continues.
   
</pre>

                   
                                </form>
    
        </div>
        
</html>